[{"categories":["Projektmanagement"],"contents":"In den letzten 1,5 Jahren habe ich mich intensiv mit Konzepten, Prozessen und Werkzeugen befasst, die dabei helfen sollen, die Softwareentwicklung zu modernisieren. Der Aufbau einer Microservice-Architektur, Umstellung auf DevSecOps und der Schritt in die Cloud sind die wesentlichen Eckpfeiler davon. Nichts davon lässt sich von heute auf morgen einfach so herzaubern. Für alle Beteiligten ist es eine große Umstellung im Denken und Handeln. Langfristig erhoffe ich mir, dass damit die Produktivität der Softwareentwicklung deutlich steigt. Kurzfristig gesehen muss ich gestehen, dass der Weg dahin einem einiges abverlangt. Es wäre naiv zu erwarten, dass eine reine Willenserklärung ausreicht. Die neuen Strukturen, Denkweisen, Wissen und notwendige Infrastruktur gehören erst aufgebaut. Da kommt es zwischenzeitlich schon mal zu etwas Chaos. Daher ist es umso wichtiger, zu jedem Zeitpunkt das langfristige Ziel klar im Auge zu behalten: Mit den neuen Prozessen und Werkzeugen die von den KundInnen benötigte Software effizient und zu den geforderten Qualitätskriterien bereitstellen.\nDen Aspekt Qualität in Softwareprojekte zu bringen, behandle ich in anderen Artikeln. Was aber heißt es, Software effizient bzw. produktiv zu entwickeln? Diese Frage hab ich mir in letzter Zeit oft gestellt. In diesem Artikel analysiere ich mögliche Faktoren, die sich meiner Erfahrung nach positiv, aber auch negativ auf die Produktivität auswirken können.\nProduktivität in Software Development Teams Fangen wir mit etwas Grundlagenarbeit an. Was ist denn überhaupt Produktivität in der Softwareentwicklung? Dazu gibt es wahrscheinlich viele, viele Definitionen und noch mehr Arten, diese zu analysieren und zu messen. Das zu googlen, überlasse ich jedem Leser/jeder Leserin selbst. Die Frage, die ich mir also stelle, ist nicht, wie Produktivität in der Literatur definiert wird, sondern was mein Umfeld und ich darunter verstehen. Bei mir - und vermutlich auch bei vielen anderen - taucht beim Thema Produktivität im Kopf sofort auf, viele Dinge ganz schnell zu erledigen. Schnell einige Problem lösen, schnell codieren, schnell viele Features an den Kunden liefern, schnell irgendwas dokumentieren. Wenn ich diesen Gedanken näher betrachte, suggeriert dieser aber ein falsches Bild. Viele Dinge \u0026ldquo;schnell\u0026rdquo; zu erledigen, heißt nicht, auch die Wünsche der KundInnen zu befriedigen. Also habe ich etwas länger darüber nachgedacht\u0026hellip;\nIm Wesentlichen geht es bei Produktivität darum, die richtigen Dinge zu erledigen.\n Get the right things done!\n Was sind aber die richtigen Dinge? Dazu ist es notwendig, die Ziele und Prioritäten zu kennen, um sich an diesen klar ausrichten zu können. Umgelegt auf die agile Softwareentwicklung heißt das für mich:\n Produktivität ist die Fähigkeit, Anforderungen mit Fokus auf den KundInnennutzen zu priorisieren und diese mit den definierten Qualitätskriterien entwickelt auszuliefern - und das so oft wie möglich.\n Eines ist aus meiner Sicht empfehlenswert: für das Projekt bzw. das Team ein gemeinsames Verständnis von Produktivität zu finden. Damit ist gewährleistet, dass jede(r) das Ziel hinsichtlich Produktivitätsanforderungen kennt und damit auch dazu beitragen kann, dieses zu erreichen.\nWie steigert man Produktivität? Zuerst einmal stellt sich die Frage: habe ich überhaupt ein Produktivitätsproblem? Das ist eine Frage, die vermutlich gar nicht so leicht zu beantworten ist. Ich kann hier an dieser Stelle nur für mich beantworten, warum mich das Thema gerade interessiert:\n Menschen und Organisationen, die agil arbeiten und sich weiterentwickeln wollen, halten immer wieder einmal inne um zu reflektieren, dazuzulernen und Gelerntes umzusetzen. Das betrifft natürlich auch die Thematik Produktivität. Viele, viele Aufträge und Fristen machen es unumgänglich, jegliche inneffiziente Lücken aufzudecken und zu beseitigen. Effizienz macht es möglich, auf dem Markt zu bestehen und sich gegenüber der Konkurrenz abzuheben. Je produktiver ich/wir arbeiten und KundInnenanforderungen erfüllen, desto weniger Druck ist seitens KundInnen und Vorgesetzten zu erwarten, es sind keine nächtlichen Huschpfusch-Aktionen notwendig und unnötige Überstunden lassen sich damit auch vermeiden. Damit stimmt am Ende die Work-Life-Balance für die MitarbeiterInnen. Eine Balance zwischen KundInnenwünschen, den Bedürfnissen der Vorgesetzten sowie der MitarbeiterInnen zu finden macht alle glücklich, und das sollte doch das Ziel einer jeden Organisation sein!  Um mögliche Verbesserungspotenziale hinsichtlich Produktivität zu finden, habe ich verschiedenste Bereiche des Entwicklungsalltags näher betrachtet. Nachfolgend habe ich diese Bereiche und meine Erkenntnisse aufgelistet.\n1. Agiles Vorgehen Agile Methoden sind mittlerweile sehr verbreitet und versprechen effiziente Softwareentwicklung. Sich für diese Vorgehensweise zu entscheiden, halte ich auch für sehr schlau. Was ich aber ebenso beobachte, sich \u0026ldquo;agil\u0026rdquo; auf die Fahnen zu heften, heißt nicht notwendigerweise agile Methoden auch sauber umzusetzen. Wie viele Arten von \u0026ldquo;Scrum\u0026rdquo; wird es in der Praxis tatsächlich geben?\n \u0026ldquo;Wir machen jetzt Scrum! Wir stellen uns jeden Morgen zusammen und reden miteinander!\u0026rdquo; \u0026ldquo;Scrum Master? Brauchen wir nicht!\u0026rdquo; \u0026ldquo;Die Retrospektive ist bei uns nicht wichtig. Die lassen wir aus.\u0026rdquo; \u0026ldquo;Bei uns ist der Product Owner auch der Scrum Master.\u0026rdquo; \u0026ldquo;Bei uns gibt es mehr POs als EntwicklerInnen.\u0026rdquo;  Sich bei der Umsetzung von agilen Vorgehensmodellen nicht selbst anzulügen, ist meines Erachtens nach ein wichtige Faktor, um in den versprochenen Genuss der effizienten und kundenorientierten Softwareentwicklung zu kommen. Auch wenn die Umstellung auf agile Softwareentwicklung einmal geglückt ist und man vorbildhaft darin ist, heißt das nicht, dass sich nicht auch blinde Flecken einschleichen. Nach über 10 Jahre Scrum stelle ich gerade wieder fest wie wichtig es ist, die angewandten Methoden und Prozesse regelmäßig zu betrachten, radikal ehrlich zu sein um festzustellen, ob wir uns etwas schönreden, was eigentlich schon längst verbessert gehört. Ein Blick von Außen durch Externe, neue MitarbeiterInnen oder einem guten Scrum Master kann hier viel Gutes leisten. Verschläft man das allerdings, kann so manche Unausgewogenheit Auswirkungen auf die Produktivität haben.\nAbweichungen reflektieren Abweichungen vom Bilderbuch-Scrum gehören begründet und auch in regelmäßigen Abständen reflektiert, ob diese tatsächlich aufgrund der Projektsituation noch notwendig sind.\nGröße des Scrum-Teams Auch ein Scrum-Team verändert sich mit der Zeit. Irgendwann kann ein Team eine Größe erreichen, in dem zu viele Kommunikationslinien entstehen und die Zusammenarbeit inneffizient wird. Was hier eine sinnvolle Größe ist, da sind mir schon verschiedene Angaben untergekommen wie \u0026ldquo;ein Scrum-Team hat 7 (+/- 2) MitarbeiterInnen\u0026rdquo; oder \u0026ldquo;maximal 12 Teammitglieder\u0026rdquo;. Hier gilt es das Team, die Mitglieder und die Projektstruktur aufmerksam zu beobachten und wenn nötig, Anpassungen der Organisationsstruktur vorzunehmen.\nMeetings Die vorgegebenen Meetings der gewählten Methodik sollten eingehalten und effizient gestaltet werden:\n Saubere und effiziente Planungs-Meetings (z.B. Vorbereitung von Backlogpunkten, Feinplanungen in kleineren Runden bei sehr großen Scrum-Teams). Retrospektiven auch tatsächlich nutzen, um zu lernen und Verbesserungspotenziale zu identifizieren. Auf die Länge von Daily Scrums achten, aber auch auf die Einhaltung dieser.  Klare Projektziele, klare Anforderungen und klare Prioritäten Um produktiv Kundennutzen zu generieren, muss für alle klar sein, wohin das Schiff fährt und welches Ziel angesteuert wird. Die konkreten Anforderungen definieren, was dazu notwendig ist und die Prioritäten machen es möglich, diese effizient in der benötigten Reihenfolge abzuarbeiten. Zu jedem Zeitpunkt sollte dem Team bekannt sein was als Nächstes zu tun ist, um dem Ziel näher zu kommen!\nDas heißt nicht, dass das gesamte Projekt bis ins Detail durchgeplant sein soll, sonst wäre es keine agile Vorgehensweise sondern ein Wasserfallmodell. Wir müssen nicht den gesamten Weg bis zum Ziel kennen, aber die nächsten Schritten müssen bekannt und in Form klarer Anforderungen und Prioritäten definiert sein.\nWenn ich das so schreibe, klingt das in der Theorie auch recht schön. Nun habe ich die Erfahrung gemacht, dass bei neuen Projekten mit neuen Methoden und Technologien die nächsten Schritte nicht immer ganz \u0026ldquo;klar\u0026rdquo; definierbar sind. Das erste mal eine Microservice-Architektur für eine Produktlandschaft zu entwerfen, die ersten Microservices mit Cloud-Komponenten betreiben, die erste Deployment-Pipeline einrichten, die ersten UIs designen, \u0026hellip; Da sind die nächsten Schritte nicht immer soooo klar. In solchen Phasen entstehen sehr schwammige und grobe Anforderungen in einem Sprint, die eher Fragestellungen gleichen wie \u0026ldquo;Herausfinden, wie man eine Deployment-Pipeline einrichtet\u0026rdquo; oder \u0026ldquo;Microservices schneiden\u0026rdquo;. Sowas lässt sich anfangs nicht vermeiden. An diesem Punkt ist es wichtig, Antworten zu bekommen um herauszufinden, was überhaupt die nächsten Schritte sein müssen, um später den KundInnennutzen befriedigen zu können. Hierbei ist darauf Acht zu geben, dass diese Phase nur vorübergehend besteht und nicht zum Normalzustand wird! Um aus dieser Phase herauszukommen hilft es, sich selbst, POs und EntwicklerInnen bei der Definition von Backlog- und Sprint-Backlogeinträgen immer wieder zu zwingen, so klar wie möglich die Ziele und Schritte zu formulieren, seien sie auch noch so klein. Das bedarf etwas Übung und funktioniert auch nicht immer auf Anhieb - es ist aber wichtig, daran zu arbeiten.\n2. Überflüssiges lokalisieren und bereinigen Ziel ist es, überflüssige Tätigkeiten und Aufwände zu identifizieren, die Ressourcen binden, aber keinen echten Nutzen generieren. Vermeidbar sind beispielsweise unnötige Abläufe und Bürokratie, nicht notwendige Besprechungen oder die Entwicklung von Anforderungen oder Hilfstools, die in Wahrheit (fast) keiner benötigt.\nAuch Engpässe binden Ressourcen, die anders eingesetzt werden könnten. Diese sind ganz unterschiedlicher Natur und zeichnen sich dadurch aus, dass es zu einem Flaschenhals kommt und Wartezeiten entstehen. Ein paar Beispiele:\n Engpass in der Infrastruktur: Hardware hat lange Lieferzeiten oder wurde zu spät bestellt, benötigte Software wird nicht angekauft oder freigegeben. Stehzeiten: Jemand wartet auf jemand anderes und kann nicht weiterarbeiten. Ursachen sind möglicherweise inneffiziente Freigabeprozesse, fehlende Informationen, falsche Planung, falsche Aufgabenverteilung oder fehlende Ausbildung der MitarbeiterInnen. Personalengpässe: Zu wenig/nicht verfügbare ArchitektInnen in Design-Phasen, zu wenig/nicht verfügbare EntwicklerInnen in Phasen der Feature-Entwicklung, zu wenige Requirements Engineere, die Anforderungen aufbereiten.  3. Kommunikation und Besprechungen Normalerweise ist Kommunikation ein Thema, das in vielen Organisationen eher zu kurz kommt. Darum möchte ich dieses Thema mit Vorsicht ansprechen. Meiner Erfahrung nach gibt es selten zu viel davon. Was aber sehr wohl einen Unterschied macht, ist die Form der Kommunikation.\nAchtet man nicht drauf, können auch hier Problemfelder entstehen, die Auswirkung auf die Gesamtproduktivität haben. Viele Kommunikationslinien, lange Kommunikationswege, fehlende Kommunikation und daher fehlende Information können die Ursache dafür sein. Einen besonderen Stellenwert nehmen hierbei auch Besprechungen ein. Viele Besprechungen mit vielen TeilnehmerInnen, unvorbereitete Besprechungen ohne klare Agenda und Zielsetzung sowie Teilnahme an Besprechungen, bei denen man aber keinen Beitrag leisten kann, verursachen Produktivitätseinbußen.\nKommunikation und Abstimmungsformen sind etwas sehr Dynamisches. Die Situation im Projekt/Team gehört immer wieder neu betrachtet und wenn notwendig, der Kurs korrigiert.\n4. Fokus und \u0026ldquo;Flow\u0026rdquo; Ich treffe selten jemanden aus unserer Branche, der/die nicht jammert über zu viel Stress und Arbeit. Prinzipiell ist das ein gutes Zeichen für die IT, andererseits kein gutes Zeichen für die Menschen (Burnout \u0026amp; Co lassen grüßen\u0026hellip;). Was bei der vielen Arbeit oft verloren geht, ist der Fokus auf das Wesentliche - auf die wirklich wenigen wichtigen Dinge. Wer priorisieren und daher zu einem Zeitpunkt immer den Fokus auf die aktuell wichtigste Aufgabe halten kann, bringt meiner Erfahrung nach gesamt gesehen mehr Leistung als jemand, der/die versucht zu multitasken und gleichzeitig auf zu vielen Baustellen unterwegs zu sein.\nAls ich kurze Zeit dachte, ich möchte Fluglotsin werden (nicht zu verwechseln mit Flugbegleiterin ;-)), war es ein schwerer Schlag ins Gesicht, als ich nach dem Aufnahmetest die Antwort bekam \u0026ldquo;leider durchgefallen, Sie haben bei den Multitasking-Aufgaben nicht gut abgeschnitten\u0026rdquo;. Autsch! Es war sicher besser für die Welt, damit keine Flugzeuge abstürzen. Was aber mache ich? Eine Frau, die nicht multitaskingfähig ist? In der Softwareentwicklung gab es zum Glück Platz für mich. Was ich nämlich an diesem Job liebe ist, dass man bei der Lösung eines Problems oder beim Finden eines Fehlers so richtig tief eintauchen und rundum alles ausblenden kann. Fokus par excellence!\nSeit ich Kinder habe, sind diese Momente rar. Seit ich sehr viel Software-Projektmanagement mache, ebenso. Ich halte es aber für absolut unumgänglich, als SoftwareentwicklerIn für Zeiten zu sorgen, in denen man ungestört arbeiten kann. Ich nenne das auch gerne in den \u0026ldquo;Flow\u0026rdquo; zu kommen. Das Wort gefällt mir und passt für die Softwareentwicklung genauso wie für Yoga oder Kinder beim Spielen.\nWird der Softwareentwicklungsalltag immer wieder unterbrochen (wenn auch nur kurz), ist es schwer, in einen längeren Zustand der Konzentration zu kommen. Bei Kindern heißt es, wenn sie beim Spielen im \u0026ldquo;Flow\u0026rdquo; sind, darf man sie nicht unterbrechen. Nicht mal mit ihnen reden. Werden sie andauernd aus diesem Zustand gerissen, lernen sie nie, sich für längere Zeit zu konzentrieren. Aus der Softwareentwicklung kenne ich das ebenso. Es braucht bei mir oft ein wenig, bis ich richtig konzentriert in ein Thema eintauche, aber dann entwickeln sich wie von selbst sehr kreative Lösungen. Umgekehrt kennt jeder auch diese Situationen immer wieder unterbrochen zu werden. Ein Task wird einfach nicht fertig, nach jeder Unterbrechung muss man sich wieder reindenken, kaum ist man dabei richtig loszulegen, nächste Unterbrechung. Wieder von vorne\u0026hellip; Wenn es vielen MitarbeiterInnen so geht, kann man sich vorstellen, was das für die Produktivität heißt!\nZusammenfassend heißt das: um Produktivität zu steigern, hilft es für Fokus und \u0026ldquo;Flow\u0026rdquo; zu sorgen.\nHier in paar Anregungen:\n Besprechungen unterbrechen den Flow. Abhilfe: Besprechungsfreie Zeiten einplanen, Besprechungen an bestimmte Tage bzw. Tageszeiten legen. Zeiten der ungestörten Arbeit genauso einplanen, wie Besprechungen. Wenn ich weiß, ich hab ein kniffliges Thema, blocke ich mir gerne ganze (Halb-)Tage aus, um mich nur diesem Thema zu widmen. Dafür sorgen, dass man nicht unterbrochen wird. Ich habe festgestellt (Danke Corona!), dass sich Homeoffice super dafür eignet, vor allem wenn man ansonsten im Großraumbüro sitzt. Ist man im Büro, kann man den KollegInnen anders mitteilen, dass man gerade nicht gestört werden möchte (durch explizite Kommunikation, durch ein Zeichen oder Symbol auf dem Tisch, etc.) Limit your Work-in-Progress! Es ist ein Mantra, dass genauso im Projektmanagement also auch im persönlichen Alltag gilt. Zu viele Baustellen machen einen langsamer, als schneller. Je weniger Baustellen gleichzeitig vorhanden sind, um so fokussierter kann man sich genau der einen Sache widmen, die gerade am Wichtigsten ist. Lerne dich selbst kennen! Jede(r) tickt und arbeitet anders. Wenn man sich selber gut beobachtet und kennenlernt, erkennt man auch, wie die Voraussetzungen sein müssen, um konzentriert arbeiten und daher gute Leistung bringen zu können. Ich für mich weiß, dass ich ausgeschlafen sein muss und ich spät abends nicht mehr viel auf die Reihe bekomme. Habe ich aber die Möglichkeit, in den frühen Morgenstunden zu arbeiten, ist das eine sehr produktive Zeit! Ich kenne aber auch Menschen, die sind richtige Eulen und haben die besten Ideen, wenn es schon dunkel wird. Probiere verschiedenes aus, finde heraus, was für dich passt und kommuniziere es deinen TeamkollegInnen. So kann aus vielen einzelnen Produktivitätsoptimierungen gesamtheitlich viel erreicht werden!  5. Werkzeuge und Prozesse Ein weiterer Bereich, welcher Einfluss auf die Effizienz von Entwicklungsteams hat, ist der Einsatz passender Werkzeuge und Prozesse. Nicht ohne Grund gewinnen Microservice-Architekturen, DevOps, Automatisierung und die Cloud an Bedeutung. Aber Vorsicht: Langfristig sollen Teams damit produktiver werden und sich auf die Entwicklung von Fachfunktionalität anstatt Infrastrukturthemen konzentrieren können. Kurzfristig gesehen müssen aber Wissen, technische Voraussetzungen und Organisationsstrukturen erst einmal aufgebaut werden. Das bedingt eine entsprechende Lernkurve sowie Umstellungsphase. Alle Betroffenen sollten sich daher gerade zu Beginn keine unrealistischen Hoffnungen machen, von heute auf morgen das volle Potenzial der Produktivitätssteigerung zu spüren, die Cloud, DevOps \u0026amp; Co versprechen.\nZusammenfassung Produktivität ist die Voraussetzung dafür, langfristig auf dem Markt zu bestehen und für die eingesetzten Ressourcen auch den erwarteten Nutzen zu generieren. Leider gibt es sehr viele Einflussfaktoren, die sich auf die Gesamtproduktivität auswirken können. Das betrifft die eigene als auch die Produktivität des Teams. Um mögliche Problemfelder zu identifizieren ist es ratsam, in regelmäßigen Abständen den Blick auf die Produktivität zu richten: welches Vorgehensmodell wird eingesetzt und wie wird es umgesetzt? Wo verschwende(n) ich/wir Ressourcen? Gibt es Engpässe und entstehen dadurch unnötige Wartezeiten, die Kosten produzieren aber keinen Nutzen generieren? Wie effizient ist die Kommunikation gestaltet? Liegt der Fokus auf den wirklich wichtigen Dingen und gibt es Zeiten der ungestörten Arbeit daran? Können geeignete Werkzeuge und Prozesse helfen, produktiver zu werden?\n","permalink":"https://www.maria-strasser.at/blog/produktivitaet-in-software-development-teams/","tags":["Software Development","IT-Management","Produktivität"],"title":"Ein kritischer Blick auf Produktivität"},{"categories":["Testautomatisierung"],"contents":"Nachdem mein Mann schon angekündigt hat, dass der nächste Artikel über Testautomatisierung ist, widme ich mich heute einem meiner Lieblingsthemen. Ähnlich wie beim Thema DevOps geht es mir aber so, dass ich einen Artikel darüber schreiben möchte, jedoch feststelle, dass das Thema sehr umfangreich ist. Darum wird es wohl eher eine Artikel-Serie geben. Ich starte damit, anhand von Praxisbeispielen zu erarbeiten, WARUM aus meiner Sicht Testautomatisierung wichtig ist.\nEine Liebesgeschichte Ich kam mit Testautomatisierung schon sehr früh in Berührung. Damals (vor ca. 12 Jahren) war die Thematik noch sehr jung. Im Zuge meines HTL-Berufspraktikums durfte ich eine Bibliothek schreiben, die es erleichtern sollte, Winforms-Komponenten automatisiert zu testen. Bis dahin hatte ich keine Ahnung, dass es sowas wie automatisierte Tests überhaupt gibt. Während meiner Schulausbildung wurde noch kein Wort darüber verloren, und auch in meinem IT-Bekanntenkreis gab es kaum jemanden, der/die sich intensiver mit Unit-Tests, Integrationstests oder UI-Tests beschäftigte.\nDurch die intensive Auseinandersetzung mit Testautomatisierung im Zuge der darauffolgenden Diplomarbeit, wurde mir bewusst, wie wichtig es ist, diesem Thema Aufmerksamkeit zu schenken. So blieb ein Teil meines Softwareentwicklerinnenherzens bei diesem Themenfeld hängen. Heute ist Testautomatisierung aktueller denn je, vor allem in agilen Projekten.\nDefinition Testautomatisierung umfasst alle Tätigkeiten, die dafür sorgen, manuelle Testaufwände in Softwareprojekten zu reduzieren, gleichzeitig jedoch eine hohe Softwarequalität trotz ständiger Weiterentwicklung sicherzustellen. Im Wesentlichen geht es darum, Tests durch den Einsatz verschiedenster Techniken und Tools zu erstellen, um diese jederzeit automatisiert durchführen zu können. Dabei umfasst Testautomatisierung, neben der Erstellung der Tests, auch eine strategische Ebene, die Ziele und Rahmenbedingungen festlegt.\n Welche Qualitätsansprüche hat das Projekt? Welche Typen von Tests werden in welchem Ausmaß erstellt? Welche Testabdeckung wird angestrebt? Welche Ressourcen werden dafür eingesetzt?  Für diese Entscheidungen ist es notwendig, die unterschiedlichen Typen automatisierter Tests, deren Entwicklungsaufwand sowie sinnvoller Verteilung zu kennen. Das wird üblicherweise mit der Test-Pyramide 1 visualisiert.\nTestautomatisierung - eine Selbstverständlichkeit? Im Zuge neuer Projekte beschäftige ich mich derzeit intensiv mit der Qualitätssicherung der Software. Eine wichtige Säule ist hier die Testautomatisierung auf den verschiedensten Ebenen: Unit-Tests, Integrationstests, UI-Tests, Last- und Performancetests sowie Security-Tests. Einige dieser Arten stellen für mich noch Neuland dar, manche passen auch nicht für jedes Projekt, und über manche denke ich gar nicht mehr nach, so zum Beispiel über Unit-Tests. Für mich ist es selbstverständlich, dass jede Funktionalität mindestens mit Unit-Tests getestet wird. Wenn ich aber über die Grenzen meiner rosaroten kleinen Welt hinausschaue, und im Austausch mit anderen Projekten bin, fällt mir doch eines auf: Testautomatisierung ist noch NICHT überall angekommen und so selbstverständlich in die tägliche Arbeit eingebettet, wie ich das angenommen hätte!\nIn Gesprächen über Projekte ohne automatisierte Tests versuche ich nach außen hin verständnisvoll und sachlich zu bleiben. Innerlich verfalle ich aber in einen kompletten Panikmodus. Für mich persönlich wäre es undenkbar, geschäftskritische Lösungen ohne automatisierte Tests zu entwickeln und auszurollen. Klar, vor Releases kann man genug Zeit für manuelle Tests einplanen. Die Realität sieht jedoch anders aus, und so gibt es auch Situationen, wo die Zeit, alles durchzuklicken, eben nicht bleibt. Seiteneffekte sind hierbei vorprogrammiert. Die Erkenntnis, dass die Automatisierung von Tests in manchen Softwareprojekten noch keine Rolle spielt, macht mich sehr nachdenklich. Darum möchte ich anhand meiner konkreten Projekterfahrungen zeigen, warum automatisierte Tests für mich nicht mehr wegzudenken sind.\nKontinuierliche Weiterentwicklung bedingt Testautomatisierung Die Vorteile der Testautomatisierung lassen sich am besten anhand von Beispielen aus der Praxis verdeutlichen. Vor 10 Jahren begann ich bei einer Neuentwicklung eines großen Softwareprojekts mitzuwirken, an dem noch heute intensiv weiterentwickelt wird. Von Beginn an wurden Unit-Tests erstellt, und diese automatisiert im Zuge des nächtlichen Build-Prozesses ausgeführt. Zugegeben, es war oftmals echt eine Überwindung genug Zeit und Motivation zu finden, umfangreiche Unit-Tests zu schreiben. Über die Jahre sind die Vorteile jedoch klar erkennbar geworden:\n Die tägliche automatisierte Ausführung von tausenden von Unit-Tests gibt den EntwicklerInnen spätestens am nächsten Tag unmittelbar Rückmeldung, ob eine Änderung Seiteneffekte hat. Der Umfang an Funktionalität in diesem Projekt und die Release-Zyklen von monatlichen Sprint-Releases bzw. wöchentliche Patches würden es unmöglich machen, alles so oft händisch zu testen. Häufige Software-Releases bedingen Testautomatisierung. Habe ich aufgrund von Zeitmangel darauf verzichtet, für ein Feature Tests zu schreiben, wurden ziemlich sicher genau dafür kurze Zeit später Bugs eingemeldet. Die Erstellung von Unit-Tests bedingt eine intensive Analyse der Fehlerfälle. Diese Tatsache alleine genügt schon, um vielen Fehlern vor der Auslieferung vorzubeugen. Änderungen von Kernfunktionalitäten können relativ entspannt durchgeführt werden. \u0026ldquo;Never touch a running system\u0026rdquo; wird damit hinfällig, denn aufgrund der hohen Testabdeckung würden Seiteneffekte mit hoher Wahrscheinlichkeit von einem Test entdeckt werden. Das erste große Endkunden-Release nach einigen Jahren Entwicklung ist sehr gut verlaufen, nur wenige wirklich kritische Fehler sind aufgetreten. Somit war es nicht notwendig, lange Zeiten der Korrektur und Nacharbeit einzuplanen, sondern konnte sofort mit der Entwicklung neuer Features fortgesetzt werden. Als ich in Karenz ging, übernahmen KollegInnen \u0026ldquo;meinen\u0026rdquo; Bereich, der doch sehr viel Kernfunktionalität beinhaltete. Bei der Übernahme von Code zur Wartung und Weiterentwicklung durch andere MitarbeiterInnen stellen Tests sicher, dass bestehende Funktionalität nicht beeinträchtigt wird (und sich die Person, die den Code nun wartet und Änderungen vornehmen muss, etwas entspannen kann…). Vor einigen Jahren wurde damit begonnen, aufgrund gravierender gesetzlicher Änderungen die Software anzupassen, und es musste dazu Kernfunktionalität sehr tiefgreifend verändert werden. Ich habe die Projektleiterin gefragt, wie dieser Umbau wohl gelaufen wäre, ohne die vielen tausenden Tests, die über die Jahre entstanden sind. Die Antwort war kurz, aber für mich sehr aussagekräftig \u0026ldquo;Das möchte ich mir gar nicht vorstellen\u0026hellip;!\u0026rdquo;.  Diese Erfahrungen haben mich sehr geprägt und sind die Antwort darauf, warum ich Testautomatisierung als Selbstverständlichkeit ansehe. Mit DevOps bekommt die Thematik sogar noch einen viel höheren Stellenwert, denn kontinuierliche Weiterentwicklung und häufige Releases qualitativ hochwertiger Software sind nur mit einem hohen (Test-)Automatisierungsgrad möglich.\nFazit Testautomatisierung ist für mich die Voraussetzung dafür, geschäftskritische Applikationen über einen längeren Zeitraum mit guter Qualität entwickeln und warten zu können. Viele Fehler und Seiteneffekte können frühzeitig erkannt werden, bevor sie zu den KundInnen gelangen. Übergabe von Wartungsprojekten und Code an andere MitarbeiterInnen sowie häufige Releases werden durch automatisierte Tests erheblich erleichtert. Trotz der Vorteile bekommt das Thema noch nicht in allen Projekten einen fixen Platz. Was braucht es also, um Testautomatisierung in Softwareprojekten zu etablieren? Dieser Frage werde ich in einem Folgeartikel auf den Grund gehen.\n  https://www.borisgloger.com/blog/2018/07/11/agiles-testen-mehr-effizienz-durch-die-testpyramide/ \u0026#x21a9;\u0026#xfe0e;\n   ","permalink":"https://www.maria-strasser.at/blog/testautomatisierung-macht-doch-jeder/","tags":["DevOps","Testautomatisierung","Unit Test"],"title":"Testautomatisierung macht doch jeder?"},{"categories":["DevOps"],"contents":"Warum die DevOps-Bewegung entstanden ist, habe ich bereits hier beschrieben. Nun stellt sich allerdings die wichtige Frage: Was genau ist DevOps? Handelt es sich um den Einsatz neuer Werkzeuge? Geht es um eine spezielle Arbeitsweise? Vielleicht auch beides?\nDie Prinzipien von DevOps Was verbirgt sich nun genau hinter DevOps?\nDurch DevOps findet Agilität, die im Entwicklungsbereich bereits eine große Verbreitung hat, auch im Betrieb ihren Platz und ihre Umsetzung. Es bringt wenig, wenn die Entwicklung in kurzen Feedbackschleifen und Iterationsintervallen neue Versionen zur Verfügung stellt, wenn diese nicht in Betrieb genommen werden. Hier entsteht aber durchaus ein Zielkonflikt. Immerhin ist es der Job und die Verantwortung des Betriebs, für Stabilität zu sorgen. Jedes Update einer Software gefährdet diese gewünschte Stabilität potenziell. Folglich ist es aus Sicht des Betriebs weitaus angenehmer, wenn Software-Updates so selten wie möglich durchgeführt werden. Das führt zu großen Release-Paketen, die lange geplant und aufwändig durchgeführt werden. Da bei solch großen Releases auch mehr Fehler ausgeliefert werden, darf man die Zeit der Nacharbeiten nicht unterschätzen.\nWie also soll nun Agilität in den Betrieb finden? Auf die gleiche Weise, wie es auch in der Entwicklung der Fall ist: kurze Iterationen, um regelmäßig Feedback und kontinuierliche Verbesserung zu ermöglichen. Das heißt für die Software, dass diese nicht nur ständig weiterentwickelt, sondern auch ständig in Betrieb genommen wird. Nun fragen erfahrene BetriebsmitarbeiterInnen hoffentlich „Wie sollen wir es schaffen, so oft neue Versionen zu deployen? Wisst ihr wie aufwändig so ein Update ist?“. Und genau hier setzt DevOps an. Um das Ziel einer sich ständig weiterentwickelnden, aber stabilen Software zu erreichen, müssen Entwicklung und Betrieb an einen Tisch und gemeinsam an einem Strang ziehen. Gedankliche Grenzen und Mauern werden eingerissen, um eines zu erreichen: volle und gemeinsame Verantwortung für die Software! Der Grundsatz lautet „You build it, you run it!“.\nDie Softwareentwicklung endet nicht mehr beim Ausliefern der Software mit Betriebsanleitung, sondern dann, wenn die entwickelte Software erfolgreich in Produktion läuft. Produktionsprobleme sind damit nicht mehr alleinige Sache der BetriebsmitarbeiterInnen, sondern für die SoftwareentwicklerInnen soll transparent sein, wie es der Software gerade geht und was aus dem laufenden Betrieb gelernt werden kann. Das heißt umgekehrt, damit der Betrieb reibungslos und optimiert funktionieren kann, muss bereits bei der Konzeption der Software der Betrieb mitgedacht werden. Der erste Kontakt zum Betrieb findet nicht mehr erst dann statt, wenn die Software fertig ist, sondern bereits bei den ersten Architektur- und Release-Konzepten. Entwicklung und Betrieb entwerfen gemeinsam eine Lösung für schnelle, regelmäßige und stabile Rollouts. Damit diese Optimierung stattfinden kann, ist eines der Kernelemente die Automatisierung. Werkzeuge und Prozesse für Continuous Integration, Continuous Testing und Continuous Deployment spielen eine entscheidende Rolle, um DevOps zu kultivieren. Ohne diesen Werkzeugeinsatz und passende Technologien wird die regelmäßige Bereitstellung nur schwer umsetzbar.\nDieser Werkzeugeinsatz ist ein wesentlicher Erfolgsfaktor, reicht aber allein nicht aus. DevOps ist eine Grundausrichtung, eine Denkweise und Übereinkunft, die letztendlich durch Werkzeugeinsatz gelebt werden kann. DevOps ist ein weiterer Baustein einer Kultur, die gemeinsame Ziele und Werte in den Vordergrund stellt.\nWas bringt DevOps? Als Softwareentwicklerin frage ich mich natürlich ab und zu, ob es denn nicht einfacher wäre, so weiterzumachen wie bisher. Mitverantwortung für den reibungslosen Betrieb heißt eben auch mehr Verantwortung zu übernehmen und noch mehr mitzudenken. Betrachte ich die Situation aber aus einer gesamtheitlichen Sicht, so sehe ich für alle Beteiligten, vom Unternehmen, den EntwicklerInnen und BetriebsmitarbeiterInnen bis hin zu den EndkundInnen die Vorteile - und die sprechen meiner Meinung nach eindeutig FÜR DevOps.\nViele Firmen können schon von den Verbesserungen mit DevOps berichten. In einer groß angelegten Studie wird detailliert analysiert, wie die Bereitstellung der Software zum Unternehmenserfolg beiträgt und welche Schlüsselkompetenzen diesen leistungsstarken Unternehmen zugrunde liegen1. Aus diesem Grund habe ich ebenso große Erwartungen, was die Zukunft mit DevOps anbelangt:\n Erhöhte Qualität und Stabilität der Software Kurzes Rollout - Features und Fehlerbehebungen können den KundInnen schneller zur Verfügung gestellt werden Erhöhte Kundenzufriedenheit aufgrund der Stabilität der Software Verbessertes Monitoring für Entwicklung und Betrieb Kostenoptimierung durch bessere Stabilität, Produktivität und kürzerer Produkteinführungszeit Erhöhte MitarbeiterInnenzufriedenheit durch Transparenz in der Zusammenarbeit und durch gemeinsame Verantwortung, Ziele und Vertrauen  Fazit Wer sich noch nicht mit DevOps beschäftigt hat und auf dem IT-Markt auch in Zukunft Erfolg haben möchte, sollte sich mit dem Thema definitiv auseinandersetzen. Um Software mit hoher Produktivität, Stabilität und Qualität zu entwickeln und zu betreiben, bedarf es nicht nur der Auswahl neuer Werkzeuge, sondern der wesentliche Erfolgsfaktor sind der Kulturwandel und die Denkweise, die mit DevOps einhergehen. Agilität als gesamtheitliche Grundausrichtung, von der Anforderung bis zum Betrieb, wird damit gelebte Praxis. Ein Umstieg hört sich vielleicht erstmal anstrengend an, man sollte sich aber nicht zu Tode fürchten. Jede Veränderung beginnt mit dem ersten Schritt. Wie diese ersten Schritte konkret aussehen können, beschreibe ich in einem Folgeartikel.\n  Forsgren, Nicole/Humble, Jez/Kim, Gene (2019). Accelerate. Das Mindset von Devops, Verlag Franz Vahlen GmbH: München \u0026#x21a9;\u0026#xfe0e;\n   ","permalink":"https://www.maria-strasser.at/blog/was-ist-devops/","tags":["DevOps","DevSecOps"],"title":"Was ist DevOps?"},{"categories":["DevOps"],"contents":"Da sitzen wir nun – das Team rund um den Besprechungstisch und alle sind ganz begeistert, denn wir machen nun DevOps! Passt super zum neuen Projekt und alle anderen machen es doch auch schon, da will man nicht hinten anstehen. Außerdem hat die Erfahrung aus den Monaten zuvor gezeigt, dass wenn die Software stabil und sicher laufen soll, Entwicklung („DEVelopment“) und Betrieb („OPerationS“) enger zusammenrücken und sich gut absprechen müssen. Ein Blick in die Runde wirft jedoch Fragen auf… es sitzen nur SoftwareentwicklerInnen im Raum. Wo sind denn diese OPS, mit denen man enger zusammenrücken will? Eine noch viel wichtigere Frage: WIE macht man denn DevOps eigentlich?\nEinen Schritt zurück Spulen wir ein wenig zurück. Warum wir in unserem Team DevOps leben wollen, hat letztendlich einen Grund und eine Historie.\nIch persönlich habe mich in der Vergangenheit um den Betrieb von Software genau gar nicht gekümmert und hätte nicht im Leben daran gedacht, dass sich das für mich irgendwann ändern würde. Jahrelang war ich an der Entwicklung einer großen Desktop-Anwendung beteiligt. Zum Release-Zeitpunkt wurde von uns halbwegs automatisiert das Softwarepaket geschnürt, einen Installer gab’s auch noch im Paket dazu und das bekamen die Kundenfirmen, die gleichzeitig die Software für die EndkundInnen betrieben. Das war’s, nächster Sprint, nächste Funktionalität. Nur selten habe ich mir als Entwicklerin Gedanken dazu gemacht, wie es unserer Software im Betrieb wohl geht. Um das hat sich jemand anderes gekümmert und es lebte sich ganz gut - außer bei Betriebsproblemen…\nIst die Ursache des Problems nicht ganz klar, wird\u0026rsquo;s unangenehm. Haben die EntwicklerInnen bei der Umsetzung einen Fehler eingebaut? Wurde die Betriebsumgebung von den AdministratorInnen falsch konfiguriert? Passen die Softwareversionen der Betriebsumgebung mit der ausgelieferten Software zusammen? Wo liegt die Ursache und wer ist verantwortlich? Der Ball könnte endlos zwischen Entwicklung und Betrieb hin- und hergespielt werden. Was zu einer großen Wahrscheinlichkeit auch noch zutrifft: Auf dem Entwicklungs-PC oder dem Testserver tritt das Problem natürlich nicht auf!\nAls Entwicklerin kann ich von der Ferne und ohne nähere Kenntnisse des Betriebs in solchen Fällen nur sehr eingeschränkt helfen. Dann ist es ein bisschen so, wie wenn das eigene Kind das erste Mal alleine den Hang mit dem Schlitten runtersaust: man kann zurufen, ermutigen und Gebete sprechen, aber letztendlich kann man nicht mehr viel tun und muss seinen Sprössling dem Schicksal überlassen. Zum Glück hatte ich nur in Ausnahmefällen mit Problemen zu tun, die bei der Software ausschließlich im Betrieb auftauchten.\nDann kommt ein neues Projekt, ein Webprojekt, das sehr geprägt von der Infrastruktur der KundInnen und EndkundInnen ist. Nicht nur ist das Web nun ein völlig neues Feld, plötzlich ist es nicht mehr so einfach Softwareentwicklung und den Betrieb zu trennen. Schon zum Entwicklungszeitpunkt muss man sich so viele Gedanken über den Betrieb machen und Entscheidungen treffen. Als SoftwareentwicklerIn kann man aber doch keine Entscheidungen über den Betrieb treffen, oder doch? Immerhin will man der Firma, die die Software betreibt und sich viel besser auskennt auf dem Gebiet, nicht vorschreiben, wie die Software zu betreiben ist, oder doch? Wird das vielleicht sogar erwartet? Ist es nicht auch Aufgabe der Softwareentwicklungsfirma, die Software für die vorgegebene Zielplattform zu optimieren? Geben wir nun die Zielplattform vor? Wo ist denn die Grenze zwischen dem, was wir als SoftwareherstellerInnen an Vorgaben machen und dem, was der Betrieb entscheiden will und muss? Welche Security-Maßnahmen treffen wir, welche der Betrieb? Welche technischen Möglichkeiten haben wir denn überhaupt beim derzeitigen Betriebsmodell? Fragen über Fragen quälen den Kopf und letztendlich hilft nur eins: alle an einen Tisch. Entwicklung sowie Betrieb, um gemeinsam Rahmenbedingungen und Verantwortlichkeiten abzuklären und so die optimale Lösung zu finden. Das Ganze natürlich auch noch zu einem frühen Entwicklungszeitpunkt.\nSo ist die Erfahrung.\nWie wird das heutzutage genannt? – „DevOps“.\nDevOps ist nicht neu, und schon gar kein „Hype“ Die inhaltliche und organisatorische Trennung zwischen Entwicklung und Betrieb war und ist Alltag in vielen Firmen. Wenn die Verantwortlichkeiten klar sind und praktikabel gelebt werden können, ist das auch eine gute Sache und der Vorteil liegt klar auf der Hand: Jede Organisation kann sich auf seine Kernkompetenzen konzentrieren. Genug Betriebe haben aber auch negative Erfahrungen gemacht. Grabenkämpfe zwischen Entwicklung und Betrieb sind keine Seltenheit und in Problemfällen kommt es schnell dazu, einen Schuldigen zu suchen. Der Betrieb ist unzufrieden mit der Software und der raren Installations- und Betriebsanleitung. Bei Problemen im laufenden Betrieb haben schnell mal die SoftwareentwicklerInnen schlampig gearbeitet und dass die EntwicklerInnen über die AdministratorInnen meckern, ist auch ganz klar. Diese betreiben die Software wieder ganz anders als die EntwicklerInnen das auf dem Testserver gemacht haben. Wenn dadurch die Probleme schwer zu finden sind und der Ball ständig zwischen Entwicklung und Betrieb hin- und her gespielt wird, gibt es letztendlich einen großen Verlierer: die Software und damit die EndkundInnen.\nIn Zeiten der Optimierung, Qualitäts- sowie Produktivitätssteigerung hat so etwas keinen Platz. Die Erkenntnis, dass jene, die den Code schreiben und jene, die den Code betreiben und Support leisten, intensiver zusammenarbeiten müssen, bekam bereits vor 10 Jahren mit DevOps einen Namen. Indem der Urvater der DevOps-Bewegung Patrick Dubois1 diesen Begriff prägte und es mit dem Start diverser DevOps-Konferenzen seit 2009 auch eine Bühne dafür gibt, wird der Scheinwerfer auf diese vor allem zwischenmenschlich geprägte Thematik geworfen. DevOps ist aktueller denn je. Ein Blick in Magazine und Konferenzagenden reicht aus. Auch der aktuelle „14th Annual State of Agile“-Bericht2 demonstriert, wie weit das Thema vor allem in agil arbeitenden Unternehmen vorgedrungen ist:\n 76% of respondents stated that they currently have a DevOps initiative in their organization or are planning one in the next 12 months (compared to 73% last year).\n Es ist klar erkennbar, dass es sich nicht um einen momentanen Hype handelt, der in Kürze Geschichte ist. Vielmehr handelt es sich um eine jahrelange Entwicklung, die durch DevOps erst einen Namen bekommen hat und damit in Organisationen diskutiert und fokussiert werden kann.\nFazit DevOps basiert auf der Erfahrung vieler Unternehmen, die Lösungen für Probleme suchen, die durch die strikte Trennung von Entwicklung und Betrieb entstehen. Meine eigene Erfahrung hat gezeigt, dass zum Entwicklungszeitpunkt bereits die richtigen Fragen zum Betrieb gestellt werden müssen, um stabile und gut betreibbare Software zu entwickeln. DevOps liefert dazu die notwendige Grundlage. Als ich zum ersten Mal davon hörte, konnte ich also mit gutem Gewissen sofort begeistert zustimmen, DevOps von Anfang an in neue Projekte zu integrieren. Was sich genau hinter DevOps verbirgt, ist hier zu finden.\n  https://www.heise.de/developer/artikel/10-Jahre-DevOps-Wie-gross-du-doch-geworden-bist-4595829.html?seite=all \u0026#x21a9;\u0026#xfe0e;\n https://stateofagile.com/#ufh-i-615706098-14th-annual-state-of-agile-report/7027494 \u0026#x21a9;\u0026#xfe0e;\n   ","permalink":"https://www.maria-strasser.at/blog/hey-machen-wir-doch-devops/","tags":["DevOps","DevSecOps"],"title":"Hey, machen wir doch DevOps!"}]